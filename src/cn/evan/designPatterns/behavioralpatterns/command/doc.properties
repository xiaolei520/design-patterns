Command命令模式介绍：
 
Command命令模式是一种对象行为型模式，它主要解决的问题是：在软件构建过程中，“行为请求者”与“行为实现者”通常呈现一种“紧耦合”的
问题。
有时我们必须向某对象提交请求，但并不知道关于被请求的操作或请求的接受者的任何信息，此时无法抵御变化的紧耦合是不合适的。如：需要
对行为进行“记录、撤销/重做、事务”等处理。我们所要做的是将依赖关系转化，将紧耦合变为松耦合。

Command模式通过将请求本身变成一个对象来使行为请求者可向未指定的应用对象提出请求。
GoF《设计模式》中说道：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可
撤销的操作。


定义场景：
 
       现在来看一个场景：对于notepad大家都很熟悉，在我们使用notepad打开一个文档之后，往往做一些操作，如；输入字符(Write)、删除前
       一个字符（Delete）、撤销刚才的操作（UnDo）。现在我们就用Console程序模拟这个过程。
 
代码实现与结构分析：
 
       在实现代码前先说明实现Command模式需要烤炉的一些问题：
 
1、 一个命令对象应达到何种智能程度：命令对象的能力可大可小。这样就出现了两个极端。一是：它仅确定一个接收者和执行该请求的动作；
          一是：它自己实现所有功能，根本不需要额外的接收者对象。我给他们起了便于我方便记忆的名字，第一种叫OperationCommand，第二种叫
    ObjectCommand。当然只是为了便于记忆和理解，如有不理解，在代码实现与结构分析最后我会再谈谈我的想法，如有不妥，还请多提意见，
          一会在下面的代码中会分别对这两种情况进行示范。
 
2、 支持取消和重做：为了达到这个目的ConcreteCommand类中要存储额外的状态信息。也就是上图中ConcreteCommand的state属性。
 
3、 避免取消操作中过程中的错误积累：由于命令重复的执行、取消执行和重执行的过程可能会积累错误，以致一个应用的状态最终偏离初始值。
           这就有必要在Command中存入更多的信息以保证这些对象可被精确的复原。
 
下面来看看代码上的实现：首先，我先作一个OperationCommand的例子，先做一个请求的接收者Document（也就是结构图中的Receiver）


这两个程序中需要有几点说明：
 
1、   对于OperationCommand，我的理解是它所实现的Command只是某一个操作对于某一个接收者，所以我给它取名为OperationCommand。对于ObjectCommand，是实现这样一种对象，它实现了请求接收者的所有操作，所以取名为ObjectCommand
 
2、   在代码实例中，我对状态的保存处理相对简单，但这是因为利用了String对象的特点，当String对象被修改时，系统会重新分配一块内存。不修改原内存上的内容。如果是要保存其他的引用类型应当注意使用深拷贝，否则，所保存的状态对象都指向一个内存地址，随着状态的改变，保存不了原有的状态。
 
3、   在对象状态的保存上，我们可以使用Prototype模式。
 
Command模式的几个要点：
 
1、  Command模式的根本目的在于将“行为请求者”与“行为实现者”解耦，在面向对象语言中，常见的实现手段是“将行为抽象为对象”。
 
2、  实现Command接口的具体命令对象ConcreteCommand 有时候根据需要可能会保存一些额外的状态信息。
 
3、  通过使用Composite模式，可以将多个“命名”封装为一个“复合命令”MacroCommand。
 
4、  Command模式与C#中的Delegate有些类似。但两者定义行为接口的规范有所区别：Command以面向对象中的“接口-实现”类定义行为接口规范，更严格，更符合抽象原则：Delegate以函数签名来定义行为接口规范，更灵活，但抽象能力比较弱

