享元模式


// 面向对象的思想确实很好地解决了抽象性的问题，以至于在面向对象的眼中，万事万物一切皆对象。不可避免的是，采用面向对象的编程方式，
// 可能会增加一些资源和性能上的开销。不过，在大多数情况下，这种影响还不是太大，所以，它带来的空间和性能上的损耗相对于它的优点而言，
// 基本上不用考虑。但是，在某些特殊情况下，大量细粒度对象的创建、销毁以及存储所造成的资源和性能上的损耗，可能会在系统运行时形成瓶颈。
// 那么我们该如何去避免产生大量的细粒度对象，同时又不影响系统使用面向对象的方式进行操作呢？享元设计模式提供了一个比较好的解决方案。

// 公共交换电话网的使用方式就是生活中常见的享元模式的例子。公共交换电话网中的一些资源，例如拨号音发生器、振铃发生器和拨号接收器，都是
// 必须由所有用户共享的，不可能为每一个人都配备一套这样的资源，否则公共交换电话网的资源开销也太大了。当一个用户拿起听筒打电话时，他根
// 本不需要知道到底使用了多少资源，对用户而言所有的事情就是有拨号音，拨打号码，拨通电话就行了。所以，就有很有人会共用一套资源，非常节
// 省，这就是享元模式的基本思想。
// 假如我们要开发一个类似MS Word的字处理软件，下面分析一下将如何来实现。对于这样一个字处理软件，它需要处理的对象既有单个字符，又有由字符
// 组成的段落以及整篇文档，根据面向对象的设计思想，不管是字符、段落还是文档都应该作为单个的对象去看待。我们暂不考虑段落和文档对象，只考虑
// 单个的字符，于是可以很容易的得到下面的结构图：


// 享元的英文是Flyweight，它是一个来自于体育方面的专业用语，在拳击、摔跤和举重比赛中特指最轻量的级别。把这个单词移植到软件工程里面，也是用来表示特别小的对象，即细粒度对象。至于为什么我们把Flyweight翻译为“享元”，可以理解为共享元对象，也就是共享细粒度对象。享元模式就是通过使用共享的方式，达到高效地支持大量的细粒度对象。它的目的就是节省占用的空间资源，从而实现系统性能的改善。
我们把享元对象的所有状态分成两类，其实前面的例子中letter和fontsize属性在运行时，就形成了两类不同的状态。 
享元对象的第一类状态称为内蕴状态(Internal State)。它不会随环境改变而改变，存储在享元对象内部，因此内蕴状态是可以共享的，对于任何一个享元对象来讲，它的值是完全相同的。我们例子中Character类的letter属性，它代表的状态就是内蕴状态。
享元对象的第二类状态称为外蕴状态(External State)。它会随环境的改变而改变，因此是不可以共享的状态，对于不同的享元对象来讲，它的值可能是不同的。享元对象的外蕴状态必须由客户端保存，在享元对象被创建之后，需要使用的时候再传入到享元对象内部。我们例子中Character类的fontsize属性，它代表的状态就是外蕴状态。
所以享元的外蕴状态与内蕴状态是两类相互独立的状态，彼此没有关联。


实现和使用享元模式需要注意的问题：

面向对象虽然很好地解决了抽象性的问题，但是对于一个实际运行的软件系统，我们还需要考虑面向对象的代价问题，享元模式解决的就是面向对象的代价问题。享元模式采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。

在具体实现方面，我们要注意对象状态的处理，一定要正确地区分对象的内蕴状态和外蕴状态，这是实现享元模式的关键所在。

享元模式的优点在于它大幅度地降低内存中对象的数量。为了做到这一点，享元模式也付出了一定的代价：

1、享元模式为了使对象可以共享，它需要将部分状态外部化，这使得系统的逻辑变得复杂。

2、享元模式将享元对象的部分状态外部化，而读取外部状态使得运行时间会有所加长。

另外，我们还有一个比较关心的问题：到底系统需要满足什么样的条件才能使用享元模式。对于这个问题，我们总结了以下几条： 

1、一个系统中存在着大量的细粒度对象；

2、这些细粒度对象耗费了大量的内存。 

3、这些细粒度对象的状态中的大部分都可以外部化； 

4、这些细粒度对象可以按照内蕴状态分成很多的组，当把外蕴对象从对象中剔除时，每一个组都可以仅用一个对象代替。 

5、软件系统不依赖于这些对象的身份，换言之，这些对象可以是不可分辨的。

满足以上的这些条件的系统可以使用享元对象。最后，使用享元模式需要维护一个记录了系统已有的所有享元的哈希表，也称之为对象池，而这也需要耗费一定的资源。因此，应当在有足够多的享元实例可供共享时才值得使用享元模式。如果只能够节省百八十个对象的话，还是没有必要引入享元模式的，毕竟性价比不高。

 

什么情况下使用享元模式：

享元模式在一般的项目开发中并不常用，而是常常应用于系统底层的开发，以便解决系统的性能问题。

Java和.Net中的String类型就是使用了享元模式。如果在Java或者.NET中已经创建了一个字符串对象s1，那么下次再创建相同的字符串s2的时候，系统只是把s2的引用指向s1所引用的具体对象，这就实现了相同字符串在内存中的共享。如果每次执行s1=“abc”操作的时候，都创建一个新的字符串对象的话，那么内存的开销会很大。

如果大家有兴趣的话，可以用下面的程序进行测试，就会知道s1和s2的引用是否一致： 

	Java代码:
	
	String s1 = "测试字符串1";
	
	String s2 = "测试字符串1";
	
	//“==”用来判断两个对象是否是同一个，equals判断字符串的值是否相等
	
	if( s1 == s2 ){ 
	
	System.out.println("两者一致");
	
	}else{
	
	System.out.println("两者不一致");
	
	}


程序运行后，输出的结果为“两者一致”，这说明String类的设计采用了享元模式。如果s1的内容发生了变化，比如执行了s1 += "变化"的语句,那么s1与s2的引用将不再一致。

至于Php作为一种弱类型语言，它的字符串类型是一种基本类型，不是对象。另外，它的执行方式与Java和.Net也有明显区别，每一个脚本文件执行开始，将会装入所有需要的资源；执行结束后，又将占用的资源就立即全部释放，所以它基本上不会产生类似的性能问题，它的字符串处理的设计，自然也使用不到享元模式。

