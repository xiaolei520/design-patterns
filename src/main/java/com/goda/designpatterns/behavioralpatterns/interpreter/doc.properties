解释器模式是一种比较难理解的模式，但如果你对Command(命令模式)和Composite(组合模式)很了解的话，你会发现其实解释器模式就是这
两种的组合.为何要使用解释器模式，如何用解释器模式呢，这就是下面我们要分析的问题:
 
 
1.与Command命令模式区别
 
        首先，让我们先区别一下它与Command（命令模式的区别）
 
   1)解释器模式的意图在于使开发人员可以组合可执行对象，这些对象来自于对某公共操作提供各种解释的类层次结构。而命令模式的意图仅
             仅是一个对象中请求.
 
   2)第二，解释器模式能否作为命令使用？当然可以，可以说它是命令模式的子模式。个体应该使用哪种设计模式，取决于你的意图。如果是
             期望创建组合可执行对象的工具集就可采用解释器模式，如果是采用请求封装在对象中就可采用命令模式。
 
 
2.与Composite(组合模式)区别
 
  Interpreter模式也类似于组合模式，Composite模式通常会为单个对象和群组对象定义一个公共接口。不过，Composite模式并不要求支持
     不方式组织的结构，尽管该模式可以支持这些结构。而解释器模式通常会涉及不同类开的组合结构（所以说interpreter通常处于Composite模
     式之上）。


Interpreter模式的意图是可以按照自己定义的组合规则集合来组合可执行对象
 
 
 
下面就讲一个我们日常最经常碰到的实例：
 

   如一个公司有如下层次总裁（President),老板(Boss),项目经理（Manager),员工（Employee）
 
一天，总裁接到一个邀请开发一套医疗管理系统，于是它就把老板叫来跟他简单说一下大概，然后就把相关事情交给老板了。

老板接到任务之后，看了看，就挑了一个精明能干的开发四部项目经理(***)去安排。四部经理拿到任务之后，立即对任务进行安排.
   
   
   
上面的故事中都体现着一个意思就是每个层次都是根据上级的指令进行安排任务，所以我们就定义一个接口为Command
 
用于接收并传递指令给相应的下一级




解释器，语言和解析器 
 
解释器模式意在强调解释器的工作方式，但是它并没有指定如何在运行时组合或者实例化它们。在本章，我们通过编写JAVA代码来“手工”生成
新的解释器。但是创建一个新的解释器常见的方法就是使用解析器。解析器对象可以按照预定规则识别文本和分解文本结构，以便于进一步处理。
比如，你可以编写一个解析器，用它创建一个对应到早期伪代码形式文本程序的机器命令解释对象。 


总结：
 
典型的解释器模式至少包含接口的两个子类。 该类层次结构中的每个类分别实现一个公共操作，如execute(String orader)方法。尽管前面
没有讨论过，但这个方法需要一个“上下文”对象，用来保存重要的状态信息。
 
解释器模式同时也包括boolean或者自述表达式，它也经常使用解析器来简化新的解释器对象的创建过程。如上面的例子中，DBA员工正在开发
系统，另一个项目正需要一个DBA，于是就有了如下:

1.public class IfCommand implements Command {  
2.    protected Human human;  
3.  
4.    protected Command ifbody;  
5.  
6.    protected Command elsebody;  
7.  
8.    public IfCommand(Human human, Command ifbody, Command elsebody) {  
9.        this.human = human;  
10.        this.ifbody = ifbody;  
11.        this.elsebody = elsebody;  
12.    }  
13.  
14.    public void execute(String order) {  
15.        if (!human.isBusy()) {  
16.            ifbody.execute(order);  
17.        } else {  
18.            elsebody.execute(order);  
19.        }  
20.    }  
21.  
22.}  

为了节省资源，把首先DBA放着ifbody中，把备用DBA放入elsebody中，如果ifbody的DBA员工很忙的话，就请elsebody的DBA员工.
