策略模式(Strategy)

策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。

Context(应用场景): 

        需要使用ConcreteStrategy提供的算法。
 
        内部维护一个Strategy的实例。
 
        负责动态设置运行时Strategy具体的实现算法。
 
        负责跟Strategy之间的交互和数据传递。
 
Strategy(抽象策略类)：
 
        定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，Context使用这个接口调用不同的算法，一般使用接口或抽象类实现。
 
ConcreteStrategy(具体策略类)：
 
        实现了Strategy定义的接口，提供具体的算法实现。


应用场景和优缺点:
 
上面我们已经看过了Strategy模式的详细介绍，下面我们再来简单说说这个模式的优缺点吧！怎么说呢，人无完人，设计模式也不是万能的，每一个模式都有它的使命，也就是说只有在特定的场景下才能发挥其功效。我们要使用好模式，就必须熟知各个模式的应用场景。
 
对于Strategy模式来说，主要有这些应用场景：
 
1、  多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。(例如FlyBehavior和QuackBehavior)
 
2、  需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。(例如FlyBehavior和QuackBehavior的具体实现可任意变化或扩充)
 
3、  对客户(Duck)隐藏具体策略(算法)的实现细节，彼此完全独立。
 
 
 
对于Strategy模式来说，主要有如下优点：
 
1、  提供了一种替代继承的方法，而且既保持了继承的优点(代码重用)还比继承更灵活(算法独立，可以任意扩展)。
 
2、  避免程序中使用多重条件转移语句，使系统更灵活，并易于扩展。
 
3、  遵守大部分GRASP原则和常用设计原则，高内聚、低偶合。
 
对于Strategy模式来说，主要有如下缺点：
 
1、  因为每个具体策略类都会产生一个新类，所以会增加系统需要维护的类的数量。



状态模式经常与策略模式相混淆。有时候很难区分应当使用状态模式还是应当使用策略模式。
     这个时候，一个简单的方法便是考察环境角色是否有明显的状态和状态的过渡，如果环境角色只有一个状态，那么就应当使用策略模式。策略模式的特点是：一旦环境角色选择了一个具体策略类，那么整个环境类的生命周期里它都不会改变这个具体策略类。而状态模式则适用于另一种情况，即环境角色有明显的状态转移。在环境类的生命周期里，会有几个不同的状态对象被使用。
     另一个微妙的区别在于，策略模式的环境类自己选择一个具体策略类；而状态模式的环境类被外在的原因放进一个具体状态类中。
     策略模式所选的策略往往并不明显的告诉客户端它所选择的具体策略；而状态模式则相反，在状态模式里，环境角色所出的状态是明显告诉客户端的。
     
状态模式和策略模式 的确有相同之处:(简而言之)
状态模式 更 适用于相互间有关联，如同状态一个个跳转那样
策略模式 更单一 一个就干一个事 之间基本没有什么关联
