
在软件系统中，经常面临着“某个对象”的创建工作，由于需求的变化，这个对象的具体实现经常面临着剧烈的变化，但是它却拥有比较稳定的接口。
如何应对这种变化？提供一种封装机制来隔离出“这个易变对象”的变化，从而保持系统中“其它依赖该对象的对象”不随着需求的改变而改变？这就是
要说的Factory Method模式了。

基本上来说，FacotryMethod模式和AbstractFactory模式所作的事情是一样的，都是用来创建与具体程序代码无关的对象，只是面对的对象
层次不一样，AbstractFactory创建一系列的对象组，这些对象彼此相关。而FactoryMethod往往只是创建单个的对象。

[在这里，我想强调一下面向对象设计的一个重要思想：针对接口编程，而不是针对具体的实现编程（Code to an interface rather than to animplementation），
这个思想可以说是设计模式的基石之一。针对接口编程的好处有很多，通过接口来定义对象的抽象功能，方便实现多态和继承;通过接口来指定对象调用之间的契约，有助于协调对象之间的关系;
通过接口来划分对象的职责，有助于寻找对象，等等。AbstractFactory和FactoryMethod，还有其他的一些创建型的设计模式，都是为了实现这个目的而设计出来的。它们创建一个个
符合接口规范的对象/对象组，使得用同一个Factory创建出来的对象/对象组可以相互替换。这种可替换性就称为多态，是面向对象的核心思想之一。所以，请记住这一点：面向接口编程而非实现。]

jdk中的工厂方法模式
工厂方法是一个很常用的方法，在jdk中有很多地方用到了工厂模式，比如说Object类的toString方法。Object仅仅定义了返回String，由Object的子类来决定如何生成这个字符串，
甚至可以生成字符串的子类(如果字符串不是final类的话)。
 
意图：
定义一个用户创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。